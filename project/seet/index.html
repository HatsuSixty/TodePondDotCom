<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<script
  data-goatcounter="https://todepond.goatcounter.com/count"
  async
  src="//gc.zgo.at/count.js"
></script>
<title>Todepond dot com</title>
<link rel="shortcut icon" href="/favicon.png" />
<meta property="og:image" content="https://todepond.com/og.png" />
<meta property="og:title" content="Todepond dot com" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Todepond dot com" />
<meta name="twitter:description" content="" />
<meta name="twitter:image" content="https://todepond.com/og.png" />

<link rel="stylesheet" href="/style.css" />

<h1>SEET: Tools towards seeing the line</h1>

<p>
  Whenever I start a new project, I never know if it'll last a [long time], or
  be over [very quickly]. Today, it's the latter, but not necessarily for a bad
  reason (keep reading to find out more).
</p>

<br />

<h1>Part one: SEEING</h1>

<p>**Seet** was a short-lived project that I worked on in early 2024.</p>

<p>
  As part of that work, I did a lot of reading, and trying-things-out, and
  discussions, and I made a couple of tiny [burger king] demos. I presented my
  work at weekly [ink and switch] calls, and received a lot of feedback and
  advice, both during the calls, and afterwards (in their internal discord). I
  also shared some of my seet work on [mastodon] and the [future of coding]
  community slack, to pick up some early reactions and collaborators.
</p>

<p>But wait wait, what's this all about anyway?</p>

<h2>Can you see it?</h2>

<p>
  It has been pointed out to me that I often say ["can you see it"] a lot in the
  [demos that I give]. I say it so much that I've started to [lean into it] as a
  running joke.
</p>

<p>
  Anyway, this observation made me realise something about the projects that I
  like to work on. I like to be able to **see** whatever I'm building in that
  project, whether that's a computer program, or an artwork, or music, or
  whatever. Either way, I like to be able to **see it**. I like to be able to
  **seet**.
</p>

<p>
  And not just on the surface-level. I want to see *inside it*. I want to see
  how it works, and what's going on. I don't need to switch modes for that. I
  can [just] see it.
</p>

<h2>Spatial programming</h2>

<p>
  Being able to "see it" is a strength of [spatial programming]. It's *really
  easy* to make everything *visible* — to make everything *see-able*.
</p>

<p>
  This is because the data of your program is typically arranged in 2D space,
  which (I argue) is easier to visually present and parse, compared to
  traditional one-dimensional programming.
</p>

<p>
  In spatial programming, you can zoom in on any point, and see what's going on
  at that location, as shown by [cellpond]. You can hover over any part to see
  what data is inside, as shown by [sandspiel studio]. And you can debug any
  part of the grid by *clicking* to step through executions in that targeted
  area, as shown by the [moveable feast machine simulator]. You aren't confined
  to the narrow scope of the traditional step debugger's branching paths.
</p>

<p>
  And also, spatial programs are often coded in terms of the program's memory
  itself — it's often done with [rewrite rules] — with [before and after]
  diagrams, as shown by [MarkovJunior] and [Color Code]. You can *look* at one
  of these rewrite rules and *see* exactly what will happen, even if the
  operation is complex. You don't need to imagine anything, because you can
  **see it**.
</p>

<h2>Sentential programming</h2>

<p>
  Could we learn from spatial programming, and bring this strength to other
  paradigms? Could we create the same effect within **sentential programming*"?
  What would that look like? Is it possible? Are there reasons why that would be
  a bad idea? Are there any hurdles to discover along the way?
</p>

<p>What is sentential programming anyway?</p>

<p>
<blockquote>
  **Sentential programming** is what I called "normal programming" in my
  [cellpond LIVE presentation]. After I gave the talk, [Dave Ackley], creator of
  [SPLAT] and the [moveable feast machine], told me that I'm referring to
  "sentential programming", because it involves the 'writing of sentences' as
  opposed to the 'construction of spatial diagrams'.
</blockquote>
</p>

<br />

<h1>Part two: THE LINE</h1>

<p>Sentential programming involves working with *lines*.</p>

<h2>Code lines</h2>

<p>
  In sentential programming, the *code* that you write is made up of lines, by
  definition. You write sentences of code. Sentences are lines. Done and done.
</p>

<h2>Memory lines</h2>

<p>
  In sentential programming, the *computer memory* you work with is also a line.
  I call it `the line`.
</p>

<blockquote>*I will now proceed to argue my point.*</blockquote>

<p>
  At its lowest level, sentential programming involves manipulating data in a
  stack, or heap, or register. These are lines of memory.
</p>

<p>
  At higher levels, sentential programming can involve managing arrays of data.
  Arrays are also lines.
</p>

<p>
  At even higher levels, the data structures you work with can become more
  abstracted. You might work with a tree, or dictionary, or object, or struct,
  or key-value store. You might use some of these words interchangeably, or you
  might not. Either way I argue that these data structures are also **lines**.
  It's just that — in these cases, the **lines** are abstracted away. They're
  chopped up and arranged around in different places.
</p>

<p>
  For example, you might be working with an array-of-structs or a
  struct-of-arrays. I argue that both of these abstractions are ways of
  structuring the same underlying **line**.
</p>

<p>
  Perhaps you're only working with a single object, with keys and values. I
  still argue that this is a line. Its entries can be listed out iteratively, in
  various orders. We just happened to give portions of this line some names
  (some keys), to make our code more understandable. And also, one of the values
  of your object could be an array itself. You can have lines inside of lines.
</p>

<p>
  And even spatial programming can be viewed in terms of lines. It's typically a
  grid, laid out in memory as an array of arrays. Lines of lines.
</p>

<p>
  Noteably, [cellpond] isn't a grid — it's more similar to a network.
  Regardless, its data is modelled as sets of cells underneath — as lines.
</p>

<h2>Lines all the way down</h2>

<p>
  I argue that all programming is the mere *fiddling of memory in lines**, and
  so — if we want to make our programs more visible, we should figure out how to
  visibly represent **lines** in increasingly better ways.
</p>

<p>
  I argue that spatial programming is easy to represent visually because it
  involves a particular subset of "line arrangements" — and that subset is
  particularly easier to visualise, for whatever reason. It's hard to *not* make
  it visual.
</p>

<p>
  Even if you don't accept that "all programming is about fiddling lines", then
  I would still argue that "fiddling lines" still makes up a large proportion of
  programming, such as the examples that I covered in the previous section.
  Therefore, it's still a valuable avenue to target our work towards.
</p>

<p>
  At the very least, `the line` is a concise metaphor that serves describing a
  large
</p>
