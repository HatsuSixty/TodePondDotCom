<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<script
  data-goatcounter="https://todepond.goatcounter.com/count"
  async
  src="//gc.zgo.at/count.js"></script>
<title>Todepond dot com</title>
<link rel="shortcut icon" href="/favicon.png" />
<meta property="og:image" content="https://todepond.com/og.png" />
<meta property="og:title" content="Todepond dot com" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Todepond dot com" />
<meta name="twitter:description" content="" />
<meta name="twitter:image" content="https://todepond.com/og.png" />

<link rel="stylesheet" href="/report/style.css" />

<script type="module"></script>

<h1 id="seet-can-you-see-the-line">
  <a href="#" class="anchor">ARROOST: CREATION WITHOUT BLOCK</a>
</h1>

<p>
  Programming is an act of creation— of <a href="#">building something</a> that
  didn't exist before.
</p>
<p>
  Programming can be used to create lots of different things—
  <a>games, art, education, simulation and hardware</a>. And also music<a
    class="c"
    href="#xavier"
    >[3]</a
  >
  and plans<a class="c" href="#embark">[4]</a> and just about anything if you're
  imaginative enough<a class="c" href="#turing-completeness">[5]</a>.
</p>
<p>But it's not as simple as that.</p>

<p><br /></p>

<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#part-one">Part one: CREATION</a></li>
  <li><a href="#part-two">Part two: ARROOST</a></li>
  <li><a href="#part-three">Part three: WITHOUT BLOCK</a></li>
</ul>

<p><br /></p>
<p><br /></p>

<h1 id="part-one-see">
  <a class="anchor" href="#part-one-see">Part one: SEE</a>
</h1>

<p>It has been pointed out to me …</p>

<p>
  … that I have a habit of repeatedly saying the phrase “can you see it” in the
  demos that I give (eg:
  <a class="c" href="#spatial-programming-pipedream-foc">[3]</a>,
  <a class="c" href="#spatial-programming-without-escape">[4]</a>). Perhaps it’s
  a nervous tick, or a way to fill the silence, or an attempt to catch the
  audience’s attention. Whatever it is, I say it so much that people make fun of
  me, and I’ve started to lean into it as a running joke<a
    class="c"
    href="#normalise-sharing-scrappy-fiddles"
    >[5]</a
  >.
</p>

<p>
  Anyway, this observation made me realise something about the kinds of projects
  that I like to work on.
</p>

<p>
  In my projects, I want you to be able to <strong>see</strong> whatever you’re
  creating, whether you’re creating a computer program[^rabbits], or an
  artwork[^spellular-automata], or a music[arrows-in-arrows-in-arrows], or a
  whatever[^screens-in-screens-in-screens]. Either way, I want you to
  <strong>see it</strong>. I want you to <strong>seet</strong>.
</p>

<p>
  And not just on the surface-level. I want you to see <em>inside it</em>. I
  want you to see how it works, and what’s going on, without needing to switch
  modes, switch tools. You can just[^just] see it.
</p>

<h2 id="spatial-programming">Spatial programming</h2>

<p>
  “Being able to see it” is a strength of spatial programming[^-some-paper].
</p>

<p>
  It’s <em>really easy</em> to make everything <em>visible</em> (to make
  everything <em>see-able</em>) in spatial programming because the data of your
  program is typically arranged in 2D space[^?]. I argue that it’s much easier
  to visually present and parse, compared to the one-dimensional memory we
  typically work with in traditional programming (more on that later).
</p>

<p>
  In spatial programming, you can zoom in and <em>see</em> what data is stored
  at a location (eg: in CellPond [^spatial-programming-without-escape]). Or you
  can hover over any individual cell to <em>see</em> what data it has inside
  (eg: in Sandspiel Studio [^sandspiel-studio-60-seconds]).
</p>

<p>
  In spatial programming, you can debug a specific part of your program by
  triggering an execution in a specific place, and by <em>seeing</em> what
  happens (eg: Moveable Feast Machine Simulator[^mfms]). Combined with time
  travel debugging tools, this turns the program into a playground where you can
  prod and poke, experiment and explore. You aren’t confined to the narrow scope
  of the traditional step debugger’s branching paths (eg: Moveable Feast Machine
  Simulator[^mfms]) (again). (EDITOR: combine duplicated citations)
</p>

<p>
  And on top of that, spatial programs can be coded in terms of the program’s
  memory itself — it’s often done with rewrite rules (eg:
  MarkovJunior[^markovjunior]) — with before and after diagrams (eg:
  SpaceTode[^spacetode]) — with “when” and “then” (eg: Color Code[^color-code])
  — with programming by demonstration (eg: AgentSheets[^agentsheets]). You can
  look at one of these rewrite rules and <em>see</em> exactly what will happen,
  even if the represented operation is complex. You don’t need to imagine
  anything, because you can <strong>see it</strong>.
</p>

<h2 id="summary-of-part-one">Summary of part one</h2>

<ol>
  <li>memory in spatial programming is visible-by-default.</li>
  <li>you can debug by manipulating the program and seeing what happens.</li>
  <li>
    spatial code looks the same as its memory. you can <em>see</em> what it
    does.
  </li>
</ol>

<p>but maybe polish up a bit.)</p>

<h2 id="sentential-programming">Sentential programming</h2>

<p>
  We could ask ourselves: Could we learn from spatial programming, and bring
  these strength into other paradigms? For instance, could we create the same
  effect within sentential programming[^]? Could we allow the coder to
  <em>see</em> sentential programs in the same way we can <em>see</em> spatial
  programs)?
</p>

<p>
  Is that possible? Or are these strengths too closely linked to the nature of
  spatial programming itself? Are there any hurdles or blockers in the way of
  bringing them to sentential programming? If so, what are those hurdles?
</p>

<p>
  Regardless of whether it’s possible or not, what would a decent attempt look
  like? Has it been properly tried before? If so, how did it go? Why did they
  succeed or fail? Did different attempts all converge on the same patterns? Or
  is there a diversity of approaches out there?
</p>

<p>(EDITOR: what is sentential programming anyway??)</p>

<p>
  (WRITER: “sentential programming” is what I called “normal programming” in my
  [cellpond LIVE presentation]. after I gave the talk, [dave ackley], creator of
  [SPLAT] and the [moveable feast machine], told me that I’m referring to
  “sentential programming”, because it involves the ‘writing of sentences’ as
  opposed to the ‘construction of spatial diagrams’.)
</p>

<p><br /></p>

<h1 id="part-two-the-line">Part two: THE LINE</h1>

<p>Sentential programming involves working with <em>lines</em>.</p>

<h2 id="code-lines">Code lines</h2>

<p>
  In sentential programming, the <em>code</em> that you write is made up of
  lines, by definition. You write sentences of code. Sentences are lines. Done
  and done.
</p>

<h2 id="memory-lines">Memory lines</h2>

<p>
  In sentential programming, the <em>computer memory</em> you work with is also
  a line. I call it
  <code class="language-plaintext highlighter-rouge">the line</code>.
</p>

<blockquote>
  <p><em>I will now proceed to argue my point.</em></p>
</blockquote>

<p>
  At its lowest level, sentential programming involves manipulating data in a
  stack, or heap, or register. These are lines of memory.
</p>

<p>
  At higher levels, sentential programming can involve managing arrays of data.
  Arrays are also lines.
</p>

<p>
  At even higher levels, the data structures you work with can become more
  abstracted. You might work with a tree, or dictionary, or object, or struct,
  or key-value store. You might use some of these words interchangeably, or you
  might not. Either way I argue that these data structures are also
  <strong>lines</strong>. It’s just that — in these cases, the
  <strong>lines</strong> are abstracted away. They’re chopped up and arranged
  around in different places.
</p>

<p>
  For example, you might be working with an array-of-structs or a
  struct-of-arrays. I argue that both of these abstractions are ways of
  structuring the same underlying <strong>line</strong>.
</p>

<p>
  Perhaps you’re only working with a single object, with keys and values. I
  still argue that this is a line. Its entries can be listed out iteratively, in
  various orders. We just happened to give portions of this line some names
  (some keys), to make our code more understandable. And also, one of the values
  of your object could be an array itself. You can have lines inside of lines.
</p>

<p>
  Even when we’re building something with multiple dimensions, we often work
  represent it in a one-dimensional way. Pixels of fragment shaders are laid in
  a single line - in an array buffer[^?]. Even the DOM tags of our web page are
  arranged and presented as a vertical list - as a vertical
  <strong>line</strong>[^?].
</p>

<p>
  And even spatial programming can be viewed in terms of lines. It’s typically a
  grid, laid out in memory as an array of arrays. Lines of lines.
</p>

<p>
  Noteably, [cellpond] isn’t a grid — it’s more similar to a network.
  Regardless, its data is modelled as sets of cells underneath — as lines.
</p>

<p>
  Regardless, I see spatial programming as a subset of sentential programming.
  It’s a particular category of programming that tends to be easier to
  visualise.
</p>

<h2 id="lines-all-the-way-down">Lines all the way down</h2>

<p>
  I argue that <strong>all</strong> programming is the mere *fiddling of memory
  in lines**, and so — if we want to make our programs more visible, we should
  figure out how to visibly represent **lines** in increasingly better ways.
</p>

<p>
  I argue that spatial programming is easy to represent visually because it
  involves a particular subset of “line arrangements” — and that subset is
  particularly easier to visualise, for whatever reason. It’s hard to
  <em>not</em> make it visual.
</p>

<p>
  Even if you don’t accept that “all programming is about fiddling lines”, then
  I would still argue that “fiddling lines” still makes up a large proportion of
  programming, as highlighted by the examples that I’ve already covered.
  Therefore, I still see it as a valuable target to target our work towards.
</p>

<p>
  At the very least,
  <code class="language-plaintext highlighter-rouge">the line</code> is a
  concise metaphor that descrives a large
</p>
